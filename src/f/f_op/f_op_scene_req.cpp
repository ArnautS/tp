/* f_op_scene_req.cpp autogenerated by split.py v0.4 at 2021-03-20 21:43:05.095943 */

#include "f/f_op/f_op_scene_req.h"
#include "f/f_op/f_op_overlap_mng.h"
#include "f/f_pc/f_pc_executor.h"
#include "global.h"

// additional symbols needed for f_op_scene_req.cpp
// autogenerated by split.py v0.4 at 2021-03-20 21:43:05.095971
extern "C" {
void _restgpr_26(void);
void _savegpr_26(void);
void cPhs_Do__FP30request_of_phase_process_classPv(void);
void cPhs_Set__FP30request_of_phase_process_classPPFPv_i(void);
void fopOvlpM_Cancel__Fv(void);
void fopOvlpM_ClearOfReq__Fv(void);
void fopOvlpM_IsDoingReq__Fv(void);
void fopOvlpM_IsDone__Fv(void);
void fopOvlpM_Request__FsUs(void);
void fopOvlpM_ToldAboutID__FUi(void);
void fopScnPause_Disable__FP11scene_class(void);
void fopScnPause_Enable__FP11scene_class(void);
void fopScnRq_Execute__FP19scene_request_class(void);
void fopScnRq_FadeRequest__FsUs(void);
void fopScnRq_Handler__Fv(void);
void fopScnRq_ReRequest__FUisPv(void);
void fopScnRq_Request__FiP11scene_classsPvsUs(void);
void fopScnRq_phase_ClearOverlap__FP19scene_request_class(void);
void fpcEx_SearchByID__FUi(void);
void fpcNdRq_Delete__FP19node_create_request(void);
void fpcNdRq_Execute__FP19node_create_request(void);
void fpcNdRq_Handler__Fv(void);
void fpcNdRq_ReRequest__FUisPv(void);
void fpcNdRq_Request__FUliP18process_node_classsPvP32node_create_request_method_class(void);
void func_8001EE64(void);
void func_8001EE84(void);
void func_8001EEB4(void);
void func_8001EEE4(void);
void func_8001EF6C(void);
void func_8001EFB0(void);
}

// additional symbols needed for f_op_scene_req.cpp
// autogenerated by split.py v0.4 at 2021-03-20 21:43:05.095976
extern u8 lbl_803A38C8;
extern int l_fopScnRq_IsUsingOfOverlap;

scene_request_class* fopScnRq_phase_ClearOverlap(scene_request_class* pScnRq) {
    pScnRq = 0;

    if (fopOvlpM_ClearOfReq() == 1) {
        pScnRq = (scene_request_class*)2;
        return pScnRq;
    }

    return pScnRq;
}

void fopScnRq_phase_Execute(scene_request_class* pScnRq) {
    fpcNdRq_Execute((node_create_request*)pScnRq);
}

scene_request_class* fopScnRq_phase_IsDoingOverlap(scene_request_class* pScnRq) {
    pScnRq = 0;

    if (fopOvlpM_IsDoingReq() == 1) {
        pScnRq = (scene_request_class*)2;
        return pScnRq;
    }

    return pScnRq;
}

scene_request_class* fopScnRq_phase_IsDoneOverlap(scene_request_class* pScnRq) {
    pScnRq = 0;

    if (fopOvlpM_IsDone() == 1) {
        pScnRq = (scene_request_class*)2;
        return pScnRq;
    }

    return pScnRq;
}

int fopScnRq_phase_Done(scene_request_class* pScnRq) {
    if (pScnRq->mCrtReq.mParameter != 1) {
        fopScnPause_Disable((scene_class*)fpcEx_SearchByID(pScnRq->mCrtReq.mCreatingID));
    }
    l_fopScnRq_IsUsingOfOverlap = 0;
    return 2;
}

void fopScnRq_Execute(scene_request_class* pScnRq) {
    int tmp = cPhs_Do(&pScnRq->mReqPhsProcCls,pScnRq);
    switch (tmp) {
        case 2: {
            fopScnRq_Execute(pScnRq);
        }
    }
}

int fopScnRq_PostMethod(void* param_1, scene_request_class* pScnRq) {
    if (pScnRq->mFadeRequest) {
        fopScnPause_Enable((scene_class*)param_1);
        fopOvlpM_ToldAboutID(((scene_class*)param_1)->field_0x04);
    }
    return 1;
}

int fopScnRq_Cancel(scene_request_class* pScnRq) {

    if (pScnRq->mFadeRequest && !fopOvlpM_Cancel()) {
        return 0;
    }

    return 1;
}

request_base_class* fopScnRq_FadeRequest(s16 param_1, u16 param_2) {
    request_base_class* tmp = 0;

    if (l_fopScnRq_IsUsingOfOverlap == 0 && (tmp = fopOvlpM_Request(param_1,param_2), tmp != 0)) {
        l_fopScnRq_IsUsingOfOverlap = 1;
    }

    return tmp;
}

asm u32 fopScnRq_Request(int, scene_class*, s16, void*, s16, u16) {
    nofralloc
#include "f/f_op/f_op_scene_req/asm/func_8001F034.s"
}

asm u32 fopScnRq_ReRequest(unsigned int, s16, void*) {
    nofralloc
#include "f/f_op/f_op_scene_req/asm/func_8001F0FC.s"
}

asm void fopScnRq_Handler(void) {
    nofralloc
#include "f/f_op/f_op_scene_req/asm/func_8001F11C.s"
}